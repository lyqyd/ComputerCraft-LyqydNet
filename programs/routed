function routeDaemon ()
	local forwardTable = {}
	if fs.exists( "etc/packets" ) then
		local file = io.open( "etc/packets", "r" )
		local sLine = file:read()
		while sLine do
			table.insert(forwardTable, {dest = string.match(sLine, "(%d+)>.*"), data = string.match(sLine, "%d+>(.*)")})
			sLine = file:read()
		end
		file:close()
	end
	local longlink = false
	--longlink is used for routers that need to cache and re-send packets until success, usually because the outbound router is often not loaded.
	local routedExit = false
	while not routedExit do
		local id, packet = coroutine.yield()
		local packetType = string.sub(packet, 1, 2)
		if packetType == "HA" then
			local newRoute = net.add_route(id, string.match(packet, ";([CTR]) "), string.match(packet, ";[CTR] (%w+)"), 0, 0)
			local string = os.computerID()..":0,0;R "..os.getComputerLabel()..">"
			for rNum, rInfo in ipairs(net.routeTable) do
				if rNum ~= newRoute then
					string = string..rInfo.idNum..":"..os.computerID()..","..(rInfo.cost + 1)..";"..rInfo.type.." "..rInfo.name..">"
				end
			end
			net.packet_send("HT", newRoute, "4,4;"..string)
			for rNum, rInfo in ipairs(net.routeTable) do
				if rInfo.type == "R" and rNum ~= newRoute then
					string = net.routeTable[newRoute].idNum..":"..os.computerID()..","..(net.routeTable[newRoute].cost + 1)..";"..net.routeTable[newRoute].type.." "..net.routeTable[newRoute].name
					net.packet_send("HI", rNum, "4,4;"..string)
				end
			end
			--if the computer coming online was a router that didn't respond to a forwarded packet, forward the packet again.
			for pNum, pContents in ipairs(forwardTable) do
				if pContents.dest == id then
					rednet.send(id, pContents.data)
				end
			end
		elseif packetType == "HI" then
			net.add_route(string.match(packet, "HI:(%d+):"), string.match(packet, ";([CTR]) "), string.match(packet, ";[CTR] (%w+)"), string.match(packet, "%d+:(%d+),"), string.match(packet, ",(%d+);"))
		elseif packetType == "HQ" then
			if string.match(packet, ":(%a);") == "n" then
				for rNum, rInfo in ipairs(net.routeTable) do
					if rInfo.name == string.match(packet, ":%a;(%a+)") then
						net.packet_send("HI", net.routeFromCID(id), "4,4;"..rInfo.idNum..":"..os.computerID()..","..(rInfo.cost + 1)..";"..rInfo.type.." "..rInfo.name)
					end
				end
			elseif string.match(packet, ":(%a);") == "i" then
				for rNum, rInfo in ipairs(net.routeTable) do
					if rInfo.idNum == string.match(packet, ":%a;(%d+)") then
						net.packet_send("HI", net.routeFromCID(id), "4,4;"..rInfo.idNum..":"..os.computerID()..","..(rInfo.cost + 1)..";"..rInfo.type.." "..rInfo.name)
					end
				end
			end
		elseif packetType == "HR" then
			local routeNum = net.routeFromCID(id)
			if routeNum then
				net.remove_route(routeNum)
				for cNum, cInfo in pairs(connection.connectionTable) do
					if cInfo.route == routeNum then
						connection.connectionTable[cNum] = false
					end
				end
			end
		elseif packetType == "HT" then
			for s in string.gmatch(packet, "(%d+:%d+,%d+;[CTR] %w+)>") do
				net.add_route(string.match(s, "(%d+):"), string.match(s, ";([CTR]) "), string.match(s, ";[CTR] (%w+)"), string.match(s, ":(%d+),"), string.match(s, ",(%d+);"))
			end
		elseif packetType == "PF" or packetType == "PC" then
			local destination = tonumber(string.match(packet, ":(%d+),%d+<"))
			local routeFound = false
			local oldPacket = packet
			for rNum, rInfo in ipairs(net.routeTable) do
				if rInfo.idNum == destination then
					if rInfo.gateway ~= 0 then destination = rInfo.gateway end
					if string.match(packet, "P[FC]:%d+,%d+<(%a%a):") == "HI" then
						--These are host information packets, we must manipulate them as we send them onward so that the routing information is accurate.
						local head, gateway, cost, tail = string.match(packet, "(P[FC]:%d+,%d+<HI:%d+):(%d+),(%d+);([CTR] %a+>)")
						gateway = os.computerID()
						cost = cost + 1
						packet = head..":"..gateway..","..cost..";"..tail
					end
					if longlink then
						packet = "PC"..string.match(packet, "P[FC](:.*)")
						table.insert(forwardTable, {dest = destination, data = packet})
					else
						packet = "PF"..string.match(packet, "P[FC](:.*)")
					end
					if packetType == "PC" then
						rednet.send(id, "PS:"..oldPacket)
					end
					rednet.send(destination, packet)
					routeFound = true
				end
			end
			if not routeFound then net.packet_send("RR", net.routeFromCID(id), "4,4;"..string.match(packet, ":(%d+,%d+)<")..";not_found") end
		elseif packetType == "PS" then
			for pNum, pContents in ipairs(forwardTable) do
				if pContents.data == string.match(packet, "PS:(.*)") then
					table.remove(forwardTable, pNum)
					break
				end
			end
		elseif packetType == "SI" then
			local instruction = string.match(packet, ":(%w+)")
			if instruction == "stop" then
				if #forwardTable > 0 then
					local file = io.open( "etc/packets", "w" )
					if file then
						for pNum, pContents in ipairs( forwardTable ) do
							file:write( pContents.dest..">"..pContents.data.."\n" )
						end
						file:close()
					end
				end
				routedExit = true
			elseif instruction == "longlink" then
				longlink = true
			end
		end
	end
end

if turtle then
	return false
else
	net.daemonAdd("routed", routeDaemon, 4)
end