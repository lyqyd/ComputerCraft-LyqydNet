connectionTable = {}
local pTypeLookup = {}
pTypeLookup.query = "SQ"
pTypeLookup.response = "SR"
pTypeLookup.data = "SP"
pTypeLookup.done = "SB"
pTypeLookup.close = "SC"
pTypeLookup.fileQuery = "FQ"
pTypeLookup.fileSend = "FS"
pTypeLookup.fileResponse = "FR"
pTypeLookup.fileHeader = "FH"
pTypeLookup.fileData = "FD"
pTypeLookup.fileEnd = "FE"
pTypeLookup.fileCopy = "FC"
pTypeLookup.fileDelete = "FM"
pTypeLookup.fileMove = "FV"
pTypeLookup.fileMakeDirectory = "FK"
pTypeLookup.fileList = "FL"
pTypeLookup.fileInformation = "FI"
pTypeLookup.fileStatus = "FZ"
pTypeLookup.textWrite = "TW"
pTypeLookup.textCursorPos = "TC"
pTypeLookup.textGetCursorPos = "TG"
pTypeLookup.textGetSize = "TD"
pTypeLookup.textInfo = "TI"
pTypeLookup.textClear = "TE"
pTypeLookup.textClearLine = "TL"
pTypeLookup.textScroll = "TS"
pTypeLookup.textBlink = "TB"
pTypeLookup.instruction = "SI"
pTypeLookup.SQ = "query"
pTypeLookup.SR = "response"
pTypeLookup.SP = "data"
pTypeLookup.SB = "done"
pTypeLookup.SC = "close"
pTypeLookup.FQ = "fileQuery"
pTypeLookup.FS = "fileSend"
pTypeLookup.FR = "fileResponse"
pTypeLookup.FH = "fileHeader"
pTypeLookup.FD = "fileData"
pTypeLookup.FE = "fileEnd"
pTypeLookup.FC = "fileCopy"
pTypeLookup.FM = "fileDelete"
pTypeLookup.FV = "fileMove"
pTypeLookup.FK = "fileMakeDirectory"
pTypeLookup.FL = "fileList"
pTypeLookup.FI = "fileInformation"
pTypeLookup.FZ = "fileStatus"
pTypeLookup.TW = "textWrite"
pTypeLookup.TC = "textCursorPos"
pTypeLookup.TG = "textGetCursorPos"
pTypeLookup.TD = "textGetSize"
pTypeLookup.TI = "textInfo"
pTypeLookup.TE = "textClear"
pTypeLookup.TL = "textClearLine"
pTypeLookup.TS = "textScroll"
pTypeLookup.TB = "textBlink"
pTypeLookup.SI = "instruction"


function listen (port, time)
	--used by foreground servers to wait for incoming packets.
	port = tonumber(port)
	local listenTimeOut = nil
	if time then listenTimeOut = os.startTimer(time) end
	while true do
		local event, p1, p2, p3 = os.pullEvent()
		if event == "timer" and p1 == listenTimeOut then
			return false
		elseif event == "rednet_message" then
			routeNum, packetType, message, dist = net.rednet_message(p1, p2, p3)
			if pTypeLookup[packetType] then packetType = pTypeLookup[packetType] end
			if routeNum then
				if port == tonumber(string.match(message, "^(%d+),%d+;")) then
					for cNum, cInfo in pairs(connectionTable) do
						if cInfo.route == routeNum and cInfo.localport == port and cInfo.foreignport == tonumber(string.match(message, "^%d+,(%d+);")) then return cNum, packetType, string.match(message, ";(.*)"), dist end
					end
					local conn = {}
					conn.route = routeNum
					conn.name = net.nameFromRoute(routeNum)
					conn.localport = port
					conn.foreignport = tonumber(string.match(message, "^%d+,(%d+);"))
					table.insert(connectionTable, conn)
					return #connectionTable, packetType, string.match(message, ";(.*)"), dist
				end
			end
		end
	end
end

function listenIdle (port)
	local routeNum, packetType, message, dist = coroutine.yield()
	if pTypeLookup[packetType] then packetType = pTypeLookup[packetType] end
	if routeNum == 0 and packetType == "instruction" then return routeNum, packetType, message end
	for cNum, cInfo in pairs(connectionTable) do
		if cInfo.route == routeNum and cInfo.localport == port and cInfo.foreignport == tonumber(string.match(message, "^%d+,(%d+);")) then return cNum, packetType, string.match(message, ";(.*)"), dist end
	end
	local conn = {}
	conn.route = routeNum
	conn.name = net.nameFromRoute(routeNum)
	conn.localport = port
	conn.foreignport = tonumber(string.match(message, "^%d+,(%d+);"))
	table.insert(connectionTable, conn)
	return #connectionTable, packetType, string.match(message, ";(.*)"), dist
end

function send (conn, messType, message)
	if not connectionTable[conn] then return false end
	local packetType = ""
	if pTypeLookup[messType] then packetType = pTypeLookup[messType] else return false end
	return net.packet_send(packetType, connectionTable[conn].route, connectionTable[conn].foreignport..","..connectionTable[conn].localport..";"..message)
end

local function getPort()
	local validPort = false
	local portChoice = 51
	while not validPort do
		if net.socketTable[portChoice] then
			portChoice = portChoice + 1
		else
			net.socketTable[portChoice] = true
			validPort = true
		end
	end
	return portChoice
end

function broadcast (messType, message, toPort)
	if message == nil then return false end
	if pTypeLookup[messType] then packetType = pTypeLookup[messType] else return false end
	local fromPort = getPort()
	rednet.broadcast(packetType..":"..toPort..","..fromPort..";"..message)
	return fromPort
end

function lessResponse (port, time)
	return listenOnPort(port, time)
end

local function listenOnPort (port, time)
	port = tonumber(port)
	local listenTimeOut = nil
	local messRecv = false
	if time then listenTimeOut = os.startTimer(time) end
	while not messRecv do
		local event, p1, p2, p3 = os.pullEvent()
		if event == "timer" and p1 == listenTimeOut then
			return false
		elseif event == "rednet_message" then
			routeNum, packetType, message, dist = net.rednet_message(p1, p2, p3)
			if message and tonumber(string.match(message, "^(%d+),%d+;")) == port then
				if pTypeLookup[packetType] then packetType = pTypeLookup[packetType] end
				messRecv = true
			end
		end
	end
	return packetType, message, dist
end

function awaitResponse (conn, time)
	packetType, message, dist = listenOnPort(connectionTable[conn].localport, time)
	if packetType then
		return packetType, string.match(message, ";(.*)"), dist
	end
end

function open (idString, serverPort, timeout)
	local routeNum
	if string.sub(idString, 1, 2) == "i;" then
		--connecting to raw ID.
		routeNum = net.routeFromCID(string.sub(idString, 3))
	elseif string.sub(idString, 1, 2) == "r;" then
		--connecting to route ID.
		routeNum = string.sub(idString, 3)
	else
		--try to look up a hostname.
		routeNum = net.routeFromName(idString)
	end
	if routeNum then
		local portChoice = getPort()
		net.packet_send("SQ", routeNum, serverPort..","..portChoice..";connect")
		pType, mess = listenOnPort(portChoice, timeout)
		if not pType then return false end
		if pType == "response" then
			local conn = {}
			conn.route = routeNum
			conn.name = net.nameFromRoute(routeNum)
			conn.localport = portChoice
			conn.foreignport = serverPort
			table.insert(connectionTable, conn)
			if mess then
				return #connectionTable, mess
			else
				return #connectionTable
			end
		end
	end
	return false
end

function close (conn, message, quiet)
	if connectionTable[conn] then
		if quiet ~= true then
			if message == nil then message = "disconnect" end
			 message = connectionTable[conn].foreignport..","..connectionTable[conn].localport..";"..message 
			net.packet_send("SC", connectionTable[conn].route, message)
		end
		--must explicitly compare to true so that a string value will not evaluate as also true.
		if net.socketTable[connectionTable[conn].localport] == true then net.socketTable[connectionTable[conn].localport] = nil end
		connectionTable[conn] = nil
		return true
	end
	return false
end

function isTurtle (conn)
	if connectionTable[conn] then
		if net.routeTable[connectionTable[conn].route].type == "T" then return true else return false end
	else
		return nil
	end
end

function name (conn)
	if connectionTable[conn] then
		return connectionTable[conn].name
	end
	return false
end

function route (conn)
	if connectionTable[conn] then
		return connectionTable[conn].route
	end
	return false
end

function text (conn)
	local textTable = {}
	textTable.conn = conn
	textTable.write = function(text)
		return connection.send(textTable.conn, "textWrite", text)
	end
	textTable.clear = function()
		return connection.send(textTable.conn, "textClear", "nil")
	end
	textTable.clearLine = function()
		return connection.send(textTable.conn, "textClearLine", "nil")
	end
	textTable.getCursorPos = function()
		if connection.send(textTable.conn, "textGetCursorPos", "nil") then
			local pType, message = connection.awaitResponse(textTable.conn, 2)
			if pType and pType == "textInfo" then
				local x, y = string.match(message, "(%d+),(%d+)")
				return tonumber(x), tonumber(y)
			end
		else return false end
	end
	textTable.setCursorPos = function(x, y)
		return connection.send(textTable.conn, "textCursorPos", math.floor(x)..","..math.floor(y))
	end
	textTable.setCursorBlink = function(b)
		if b then
			return connection.send(textTable.conn, "textBlink", "true")
		else
			return connection.send(textTable.conn, "textBlink", "false")
		end
	end
	textTable.getSize = function()
		if connection.send(textTable.conn, "textGetSize", "nil") then
			local pType, message = connection.awaitResponse(textTable.conn, 2)
			if pType and pType == "textInfo" then
				local x, y = string.match(message, "(%d+),(%d+)")
				return tonumber(x), tonumber(y)
			end
		else return false end
	end
	textTable.scroll = function(lines)
		return connection.send(textTable.conn, "textScroll", lines)
	end
	return textTable
end

function processText(conn, pType, value)
	if not pType then return false end
	if pType == "textWrite" and value then
		term.write(value)
	elseif pType == "textClear" then
		term.clear()
	elseif pType == "textClearLine" then
		term.clearLine()
	elseif pType == "textGetCursorPos" then
		local x, y = term.getCursorPos()
		connection.send(conn, "textInfo", math.floor(x)..","..math.floor(y))
	elseif pType == "textCursorPos" then
		local x, y = string.match(value, "(%d+),(%d+)")
		term.setCursorPos(x, y)
	elseif pType == "textBlink" then
		if value == "true" then
			term.setCursorBlink(true)
		else
			term.setCursorBlink(false)
		end
	elseif pType == "textGetSize" then
		x, y = term.getSize()
		connection.send(conn, "textInfo", x..","..y)
	elseif pType == "textScroll" and value then
		term.scroll(value)
	end
	return
end